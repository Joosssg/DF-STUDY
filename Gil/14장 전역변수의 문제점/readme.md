<img src="https://capsule-render.vercel.app/api?type=waving&color=gradient&customColorList=1&height=200&section=header&text=Chapter14.%20%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98%20%EB%AC%B8%EC%A0%9C%EC%A0%90&fontSize=50">

# **14.1 변수의 생명 주기**

## **14.1.1 지역 변수의 생명 주기**
지역변수 생명 주기는 함수와 같다. 이때 지역변수는 호이스팅이 일어나는데 스코프 내 즉, 함수 내에서만 호이스팅 되어 스코프 최상단에 올려진 것처럼 동작한다.

<br>

## **14.1.2 전역 변수의 생명 주기**
var 키워드로 선언한 변수 생명주기는 전역 객체의 생명 주기와 일치하며, window의 프로퍼티가 된다.

<br>

# **14.2 전역 변수의 문제점**
>암묵적 결합

전역 변수는 모든 코드가 참조 할 수 있고 변경할 수 있는 암묵적 결합이 허용 되는것이다. 따라서 범위가 넓어서 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있어 위험성이 높다.

>긴 생명 주기

전역 변수는 생명 주기가 길어서 메모리 리소스도 오랜기간 소비하고 var키워드로 중복 선언이 되어서 의도치 않은 재할당이 발생할 수 있다.

>스코프 체인 상에서 종점에 존재

전역변수는 스코프 체인 최상단에 위치해 있어서 검색 속도가 가장 느리다.

>네임스페이스 오염

전역변수는 파일이 달라도 동일한 이름으로 만들어진 변수나 함수는 같은 스코프에 존재해 문제가 발생할 수 있다.

<br>

# **14.3 전역 변수의 사용을 억제하는 방법**

<br>

## **14.3.1 즉시 실행 함수**
즉시실행 함수는 정의와 동시에 한번 호출 된다. 즉시 실행 함수는 모든 코드를 괄호로 감싸 정의하므로 모든 변수가 지역 변수가 된다.

<br>

## ~~**14.3.2 네임스페이스 객체**~~

<br>

## **14.3.3 모듈 패턴**
클로저를 사용하여 전역변수를 억제할 수 있고, 캡슐화 해서 특정 함수만을 가져다 사용할 수 있다.

```js
var Gil = (function(){ //즉시실행함수
    var kim = 1;
    function numPlus(x){
        return x + 1;
    }
    return {
        _numPlus:numPlus(kim)
    }
}(/*인수*/));
console.log(Gil._numPlus);
```

<br>

## **14.3.4 ES6모듈**
ES6모듈 파일은 자체적인 독자적 모듈 스코프를 제공해 전역변수를 선언 하더라도 전역변수가 되지않고 window객체의 프로퍼티도 아니게 된다.
<br>
```html
<script type="module" src="slider.mjs"></script>
```